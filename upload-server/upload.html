<!doctype html>

<!--

  If you are a hacker, please do not hack on this. This site is only up for a couple of weeks so it was not worth the effort for me to harden it. 
  None of the data here is canonical. If you figure out a way to upload more tiles or delete someoneelses tiles, you are just makimg work
  for me to fix it. There is nothing to gain except wasting your time and my time. No glory.

  Thanks,
  josh
  
-->

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Upload Your Parcel Image</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="referrerpolicy" content="no-referrer" />
</head>
<body>
  <div class="container">
    <!-- Header (hidden after successful upload) -->
    <div id="upload-header">
      <h1>Upload Your Parcel Image</h1>
    </div>
    
    <!-- Loading state -->
    <div id="loading-state">
      <div class="spinner"></div>
      <p style="text-align: center; margin-top: 20px;">Checking access code...</p>
    </div>
    
    <!-- Upload form -->
    <div id="upload-form" class="hidden">
      <h2>Step 1: Select Your Image</h2>
      <p style="font-size: 12px; color: #888;">Best to upload a 500x500 1-bit black-and-white image, but if you upload something else, we will try our best to convert it for you.</p>
      
      <!-- Drop zone -->
      <div id="drop-zone">
        <p style="font-size: 20px;">üìÅ</p>
        <p>Drag and drop an image here</p>
        <p>or click to select a file</p>
      </div>
      <input type="file" id="file-input" accept="image/*" />
      
      <!-- Preview -->
      <div id="preview-container">
        <h2>Image Preview</h2>
        <canvas id="preview-image"></canvas>
        <p style="text-align: center; margin-top: 15px; font-size: 12px; color: #888;">
          Don't like the preview? Try seletcing a different image!
        </p>
      </div>
      
      <!-- Pre-assigned location map (only shown for claimed parcels) -->
      <div id="claimed-map-section" class="hidden">
        <h2>Step 2: Your Pre-Assigned Location</h2>
        <div id="parcel-location-display">The parcel location <span id="parcel-location-value"></span> has been reserved for you. Press the button below to upload your image!</div>
        
        <!-- Map showing only the assigned parcel -->
        <div style="margin: 20px 0;">
          <canvas id="claimed-parcel-map" width="760" height="760" 
                  style="width: 100%; height: auto; border: 2px solid #333; display: block;"></canvas>
          <p style="font-size: 12px; color: #888; margin-top: 10px; text-align: center;">
            <span style="color: #00cc00;">‚óè</span> Your parcel
          </p>
        </div>
      </div>
      
      <!-- Location selection -->
      <div id="location-section" class="hidden">
        <h2>Step 2: Choose Parcel Location</h2>
        <p>Click a green parcel to select it, or enter manually below.</p>
        
        <!-- Parcel availability map -->
        <div style="margin: 20px 0;">
          <canvas id="parcel-map" width="760" height="760" 
                  style="width: 100%; height: auto; border: 2px solid #333; cursor: default; display: block;"></canvas>
          <p style="font-size: 12px; color: #888; margin-top: 10px; text-align: center;">
            <span style="color: #00cc00;">‚óè</span> Available &nbsp;
            <span style="color: #666;">‚óè</span> Taken &nbsp;
            <span style="color: #fff;">‚óè</span> Outside writable area
          </p>
        </div>
        
        <label for="parcel-location">Parcel Location (A1 is south-west corner)</label>
        <input type="text" id="parcel-location" name="parcel-location" 
               required placeholder="e.g., A1, B12, AL38" 
               pattern="[A-Z]{1,2}\d{1,2}" 
               style="text-transform: uppercase;" />

          <p style="font-size: 12px; color: #888; margin-top: 10px; text-align: center;">
            You can also check out the <a href="/?nanes=true" target="_blank">zoomable parcel map</a> to find your favorite neighborhood.
          </p>
      </div>
      
      <!-- Upload button (shown after image is ready) -->
      <div id="upload-button-section" class="hidden">
        <h2>Step 3: Upload the Image to Your Parcel</h2>
        <div class="button-row">
          <button type="button" id="upload-btn">Upload Image</button>
        </div>
      </div>
    </div>
    
    <!-- Error Modal -->
    <div id="error-modal" class="modal hidden">
      <div class="modal-content">
        <h3>Error</h3>
        <p id="error-modal-message"></p>
        <button id="error-modal-close">OK</button>
      </div>
    </div>
    
    <!-- Success display -->
    <div id="success-display" class="hidden">
      <h2>Upload Successful!</h2>
      <p>Your parcel image has been uploaded to location: <strong id="uploaded-location"></strong></p>
      <p>Our new parcel integration team is on it. You should see it show up in the viewer within a few minutes.</p>
      <p>Here is a direct link to your parcel in the viewer:<br>
      <a id="viewer-link" href="#" rel="noopener" target="_blank">Viewer Link</a><br>
      Share it with all your friends and tell them to join you before the whole neighborhood is bought out!</p>
    </div>
  </div>

  <script>
    // Get code from URL query parameter
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    
    if (!code) {
      document.body.innerHTML = '<div class="container"><h1>Error</h1><p>No access code provided in URL.</p></div>';
    }
    
    // Elements
    const uploadHeader = document.getElementById('upload-header');
    const loadingState = document.getElementById('loading-state');
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const previewContainer = document.getElementById('preview-container');
    const previewCanvas = document.getElementById('preview-image');
    const locationSection = document.getElementById('location-section');
    const uploadButtonSection = document.getElementById('upload-button-section');
    const parcelLocationInput = document.getElementById('parcel-location');
    const uploadBtn = document.getElementById('upload-btn');
    const uploadForm = document.getElementById('upload-form');
    const successDisplay = document.getElementById('success-display');
    const uploadedLocation = document.getElementById('uploaded-location');
    const viewerLink = document.getElementById('viewer-link');
    const errorModal = document.getElementById('error-modal');
    const errorModalMessage = document.getElementById('error-modal-message');
    const errorModalClose = document.getElementById('error-modal-close');
    const parcelMapCanvas = document.getElementById('parcel-map');
    const claimedMapSection = document.getElementById('claimed-map-section');
    const claimedParcelMapCanvas = document.getElementById('claimed-parcel-map');
    
    let processedImageBlob = null;  // Store the processed image
    let availableParcels = new Set();  // Store available parcel locations
    let parcelMapData = null;  // Store parcel grid data for click detection
    let isLocationPreAssigned = false;  // Track if location is already claimed/assigned
    
    // Constants for parcel grid
    const GRID_SIZE = 38;
    const LABEL_MAX_DISTANCE = 19;
    
    // Auto-uppercase parcel location input
    parcelLocationInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });
    
    // Convert 0-based index to Excel-style letters (A, B, ..., Z, AA, AB, ..., AL)
    function indexToLetters(idx) {
      idx = idx + 1;  // Convert to 1-based
      let result = '';
      while (idx > 0) {
        idx -= 1;
        result = String.fromCharCode(65 + (idx % 26)) + result;
        idx = Math.floor(idx / 26);
      }
      return result;
    }
    
    // Build set of valid parcel locations within the 19mm circle
    function buildValidParcels() {
      const validParcels = new Set();
      const centerRow = (GRID_SIZE - 1) / 2;  // 18.5
      const centerCol = (GRID_SIZE - 1) / 2;  // 18.5
      
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          // Calculate Euclidean distance from center
          const distance = Math.sqrt(
            Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2)
          );
          
          // Skip parcels outside the circle
          if (distance > LABEL_MAX_DISTANCE) {
            continue;
          }
          
          // Convert row to letters, col to 1-based number
          const rowLetters = indexToLetters(row);
          const location = `${rowLetters}${col + 1}`;
          validParcels.add(location);
        }
      }
      
      return validParcels;
    }
    
    // Fetch list of taken parcels and draw the map
    // If onlyShowLocation is provided, only that location will be shown as available (green)
    async function drawParcelMap(canvas = parcelMapCanvas, onlyShowLocation = null) {
      try {
        // Fetch taken parcels
        const response = await fetch('cgi-bin/app.py?command=get-parcels');
        const data = await response.json();
        
        if (data.status !== 'success') {
          console.error('Failed to fetch parcels:', data);
          return;
        }
        
        let takenParcels = new Set(data.parcels || []);
        const validParcels = buildValidParcels();
        
        // If onlyShowLocation is provided, treat all parcels as taken except that one
        if (onlyShowLocation) {
          takenParcels = new Set(validParcels);  // All valid parcels are "taken"
          takenParcels.delete(onlyShowLocation);  // Except the claimed one
        }
        
        // Calculate available parcels (valid but not taken)
        availableParcels.clear();
        for (const parcel of validParcels) {
          if (!takenParcels.has(parcel)) {
            availableParcels.add(parcel);
          }
        }
        
        // Draw the grid
        const ctx = canvas.getContext('2d');
        const canvasSize = canvas.width;  // 760x760
        const cellSize = canvasSize / GRID_SIZE;  // ~20px per cell
        const margin = 2;  // 2px black margin
        
        // Clear canvas
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvasSize, canvasSize);
        
        // Store grid data for click detection
        parcelMapData = {
          cellSize: cellSize,
          margin: margin,
          validParcels: validParcels,
          takenParcels: takenParcels
        };
        
        // Draw each cell
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            const rowLetters = indexToLetters(row);
            const location = `${rowLetters}${col + 1}`;
            
            const x = col * cellSize;
            const y = (GRID_SIZE - 1 - row) * cellSize;  // Flip Y so A1 is at bottom-left (southwest)
            
            // Determine color
            let color;
            if (!validParcels.has(location)) {
              color = '#ffffff';  // White - outside circle
            } else if (takenParcels.has(location)) {
              color = '#666666';  // Gray - taken
            } else {
              color = '#00cc00';  // Green - available
            }
            
            // Draw cell with margin (black border)
            ctx.fillStyle = '#000000';  // Black border
            ctx.fillRect(x, y, cellSize, cellSize);
            
            // Draw inner colored square
            ctx.fillStyle = color;
            ctx.fillRect(x + margin, y + margin, cellSize - margin * 2, cellSize - margin * 2);
          }
        }
        
      } catch (error) {
        console.error('Failed to draw parcel map:', error);
      }
    }
    
    // Handle mouse move on parcel map (change cursor)
    parcelMapCanvas.addEventListener('mousemove', (e) => {
      if (!parcelMapData) return;
      
      const rect = parcelMapCanvas.getBoundingClientRect();
      const scaleX = parcelMapCanvas.width / rect.width;
      const scaleY = parcelMapCanvas.height / rect.height;
      
      const canvasX = (e.clientX - rect.left) * scaleX;
      const canvasY = (e.clientY - rect.top) * scaleY;
      
      const col = Math.floor(canvasX / parcelMapData.cellSize);
      const row = GRID_SIZE - 1 - Math.floor(canvasY / parcelMapData.cellSize);  // Flip Y coordinate
      
      if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
        const rowLetters = indexToLetters(row);
        const location = `${rowLetters}${col + 1}`;
        
        // Only show pointer cursor on available parcels
        if (availableParcels.has(location)) {
          parcelMapCanvas.style.cursor = 'pointer';
        } else {
          parcelMapCanvas.style.cursor = 'default';
        }
      }
    });
    
    // Handle click on parcel map
    parcelMapCanvas.addEventListener('click', (e) => {
      if (!parcelMapData) return;
      
      const rect = parcelMapCanvas.getBoundingClientRect();
      const scaleX = parcelMapCanvas.width / rect.width;
      const scaleY = parcelMapCanvas.height / rect.height;
      
      const canvasX = (e.clientX - rect.left) * scaleX;
      const canvasY = (e.clientY - rect.top) * scaleY;
      
      const col = Math.floor(canvasX / parcelMapData.cellSize);
      const row = GRID_SIZE - 1 - Math.floor(canvasY / parcelMapData.cellSize);  // Flip Y coordinate
      
      if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
        const rowLetters = indexToLetters(row);
        const location = `${rowLetters}${col + 1}`;
        
        // Only fill in available parcels
        if (availableParcels.has(location)) {
          parcelLocationInput.value = location;
          console.log(`Selected parcel: ${location}`);
        }
      }
    });
    
    // Check upload status on page load (blocks interaction until complete)
    async function checkUploadStatus() {
      try {
        const response = await fetch(`cgi-bin/app.py?command=get-parcel&code=${encodeURIComponent(code)}`);
        
        // Always expect JSON response (server always returns JSON now)
        const data = await response.json();
        
        // Hide loading state
        loadingState.classList.add('hidden');
        
        if (data.status === 'error') {
          // Code not found or other error - not authorized
          document.body.innerHTML = '<div class="container"><h1>Not Authorized</h1><p>Invalid or expired access code.</p><p>Please <a href="https://help.kickstarter.com/hc/en-us/articles/360011239834-How-to-message-a-project-creator">message us on Kickstarter</a> if you think this is in error!</p></div>';
          return;
        } else if (data.status === 'uploaded') {
          // Already uploaded - show success message with image
          uploadHeader.classList.add('hidden');
          const parcelLocation = data['parcel-location'];
          uploadedLocation.textContent = parcelLocation;
          
          // Set viewer link with full absolute URL
          const viewerBaseUrl = window.location.origin;
          const fullPathToParcel = `${viewerBaseUrl}/?parcel=${encodeURIComponent(parcelLocation)}`;
          const viewerLink = document.getElementById('viewer-link');
          viewerLink.href = fullPathToParcel;
          viewerLink.textContent = fullPathToParcel;
          
          successDisplay.classList.remove('hidden');
          return;
        } else if (data.status === 'claimed') {
          // Location claimed but image not uploaded yet - show form with pre-filled location
          const parcelLocation = data['parcel-location'];
          parcelLocationInput.value = parcelLocation;
          parcelLocationInput.disabled = true;
          parcelLocationInput.style.backgroundColor = '#f0f0f0';
          
          // Set parcel location in display text
          const parcelLocationValue = document.getElementById('parcel-location-value');
          parcelLocationValue.textContent = parcelLocation;
          parcelLocationValue.style.fontWeight = 'bold';
          
          // Add note about pre-assigned location
          const locationNote = document.createElement('p');
          locationNote.style.fontSize = '12px';
          locationNote.style.color = '#666';
          locationNote.style.marginTop = '5px';
          locationNote.textContent = `This location has been pre-assigned to you.`;
          parcelLocationInput.parentElement.appendChild(locationNote);
          
          // Show claimed map section with their parcel highlighted
          claimedMapSection.classList.remove('hidden');
          drawParcelMap(claimedParcelMapCanvas, parcelLocation);
          
          // Mark location as pre-assigned so we don't show location chooser
          isLocationPreAssigned = true;
          
          uploadForm.classList.remove('hidden');
          return;
        } else if (data.status === 'free') {
          // Valid code, no upload yet - show upload form
          uploadForm.classList.remove('hidden');
          return;
        }
      } catch (error) {
        console.error('Failed to check upload status:', error);
        // Network or parsing error - hide loading and show form anyway
        loadingState.classList.add('hidden');
        uploadForm.classList.remove('hidden');
      }
    }
    
    // Check status when page loads
    checkUploadStatus();
    
    // Drop zone click opens file dialog
    dropZone.addEventListener('click', () => {
      fileInput.click();
    });
    
    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    });
    
    // Highlight drop zone when file is dragged over
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.add('drag-over');
      });
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.remove('drag-over');
      });
    });
    
    // Handle dropped files
    dropZone.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        handleFile(files[0]);
      }
    });
    
    // Handle selected files
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });
    
    // Handle file selection
    function handleFile(file) {
      // Validate file type
      if (!file.type.startsWith('image/')) {
        showError('Please select an image file');
        return;
      }
      
      // Read and process the image
      const reader = new FileReader();
      reader.onload = (e) => {
        processImage(e.target.result);
      };
      reader.onerror = () => {
        showError('Failed to read file');
      };
      reader.readAsDataURL(file);
    }
    
    // Process image to 500x500 1-bit black-and-white PNG
    function processImage(imageDataUrl) {
      const img = new Image();
      img.onload = () => {
        try {
          // Create canvas for processing
          const canvas = document.createElement('canvas');
          canvas.width = 500;
          canvas.height = 500;
          const ctx = canvas.getContext('2d');
          
          // Draw image scaled to 500x500
          ctx.drawImage(img, 0, 0, 500, 500);
          
          // Get pixel data
          const imageData = ctx.getImageData(0, 0, 500, 500);
          const pixels = imageData.data;
          
          // Convert to black and white (1-bit)
          // Use simple threshold: brightness >= 50% = white, else black
          for (let i = 0; i < pixels.length; i += 4) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            
            // Calculate brightness
            const brightness = (r + g + b) / 3;
            
            // Threshold to black or white
            const value = brightness >= 127.5 ? 255 : 0;
            pixels[i] = value;      // R
            pixels[i + 1] = value;  // G
            pixels[i + 2] = value;  // B
            // Alpha stays the same
          }
          
          // Put processed data back
          ctx.putImageData(imageData, 0, 0);
          
          // Convert to blob
          canvas.toBlob((blob) => {
            if (!blob) {
              showError('Failed to process image');
              return;
            }
            
            processedImageBlob = blob;
            
            // Show preview
            previewCanvas.width = 500;
            previewCanvas.height = 500;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.putImageData(imageData, 0, 0);
            
            // Show preview
            previewContainer.classList.add('visible');
            
            // Only show location chooser if location is not pre-assigned
            if (!isLocationPreAssigned) {
              locationSection.classList.remove('hidden');
              // Draw the parcel availability map
              drawParcelMap();
            }
            
            // Always show upload button once image is ready
            uploadButtonSection.classList.remove('hidden');
            
          }, 'image/png');
          
        } catch (error) {
          showError(`Failed to process image: ${error.message}`);
        }
      };
      img.onerror = () => {
        showError('Failed to load image');
      };
      img.src = imageDataUrl;
    }
    
    // Upload button
    uploadBtn.addEventListener('click', async () => {
      // Validate inputs
      if (!processedImageBlob) {
        showError('Please select an image first');
        return;
      }
      
      const location = parcelLocationInput.value.trim().toUpperCase();
      if (!location) {
        showError('Please enter a parcel location');
        return;
      }
      
      // Validate location format
      if (!/^[A-Z]{1,2}\d{1,2}$/.test(location)) {
        showError('Invalid location format. Use uppercase letters and numbers (e.g., A1, B12, AL38)');
        return;
      }
      
      // Disable upload button
      uploadBtn.disabled = true;
      uploadBtn.textContent = 'Uploading...';
      
      try {
        // Create form data
        const formData = new FormData();
        formData.append('command', 'upload');
        formData.append('code', code);
        formData.append('parcel-location', location);
        formData.append('image', processedImageBlob, 'parcel.png');
        
        // Send POST request
        const response = await fetch('cgi-bin/app.py', {
          method: 'POST',
          body: formData
        });
        
        // Always parse JSON response (server always returns JSON)
        const data = await response.json();
        
        if (data.status === 'success') {
          // Show success with uploaded image
          uploadHeader.classList.add('hidden');
          const parcelLocation = data.location;
          uploadedLocation.textContent = parcelLocation;
          
          // Set viewer link with full absolute URL
          const viewerBaseUrl = window.location.origin; // e.g., https://example.com
          const fullPathToParcel = `${viewerBaseUrl}/?parcel=${encodeURIComponent(parcelLocation)}`;
          const viewerLink = document.getElementById('viewer-link');
          viewerLink.href = fullPathToParcel;
          viewerLink.textContent = fullPathToParcel;
          
          uploadForm.classList.add('hidden');
          successDisplay.classList.remove('hidden');
          
        } else if (data.status === 'used') {
          // Code already used
          showError(`This access code has already been used to upload to location ${data.location}`);
          
        } else if (data.status === 'taken') {
          // Location already taken
          showError(`Location ${data.location} is already taken. Please choose a different location.`);
          
        } else if (data.status === 'error') {
          // General error (auth, validation, etc.)
          showError(data.message || 'Upload failed');
          
        } else {
          // Unknown status
          showError('Upload failed with unknown status');
        }
        
      } catch (error) {
        showError(`Error: ${error.message}`);
        
      } finally {
        // Re-enable upload button
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Upload Image';
      }
    });
    
    // Show error modal
    function showError(message) {
      errorModalMessage.textContent = message;
      errorModal.classList.remove('hidden');
    }
    
    // Close error modal
    errorModalClose.addEventListener('click', () => {
      errorModal.classList.add('hidden');
    });
    
    // Close modal on background click
    errorModal.addEventListener('click', (e) => {
      if (e.target === errorModal) {
        errorModal.classList.add('hidden');
      }
    });
    
    // Force uppercase in location input
    parcelLocationInput.addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });
  </script>
</body>
</html>
